# HTTP. Понятия Stateful и Stateless. Запрос и ответ

Начинаем знакомство со способами сетевой коммуникации. В ближайших статьях разберем теоретическую составляющую и
затем перейдем к практике. В дальнейшем это позволит обмениваться сообщениями между клиентом и сервером или обеспечивать
межсерверную коммуникацию в разрабатываемых приложениях.

## Модель запрос-ответ. HTTP

Существует несколько способов сетевой коммуникации. Наиболее распространенным из них можно считать общение по модели
"**запрос-ответ**" (request-response).

Она заключается в отправке с клиента сообщения - запроса - и получении от сервера ответа на это сообщение.

Так, одному запросу всегда соответствует один ответ. В такой модели невозможна ситуация, когда сервер отправляет
сообщение клиенту самостоятельно.

Например, запрос к серверу происходит, когда мы вставляем какую-то ссылку в адресную строку браузера. Сервер
получает запрос, формирует и возвращает ответ, который отобразится в окне браузера - например, HTML-документ.

Именно на модели "запрос-ответ" работает самый популярный из сетевых протоколов, с которым мы сегодня познакомимся -
**HTTP***.

> *Если быть точным, мы будем ориентироваться на HTTP/1.1, но в рамках рассматриваемых тем версия протокола не будет
> иметь решающего значения.

Несмотря на название сообщений, некорректно утверждать, что запрос всегда "запрашивает" данные, а ответ их
предоставляет. В запросе вполне может предоставляться некая информация (текст, файл и т.д.), которую сервер должен
будет сохранить или иным способом обработать, а затем вернуть ответ в стиле "все прошло успешно" или "возникла
такая-то ошибка". В таком ключе можно считать, что мы запросили у сервера не информацию, а какое-то действие или
услугу.

В каждом протоколе состав запроса и ответа строго регламентирован. Это позволяет однозначно интерпретировать
содержимое запросов на сервере, а ответов - на клиенте. Регламент будет зависеть от выбранного протокола, ниже мы
рассмотрим пример для HTTP.

### HTTP-запрос

Так, HTTP-запрос выглядит примерно следующим образом:

```http request
GET / HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-GB,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
```

#### Стартовая строка

Строка, которая в примере выглядит как `GET / HTTP/1.1` называется **стартовой строкой**. Она содержит следующую
информацию:

- Метод запроса (`GET`). С методами HTTP мы познакомимся в следующей статье;
- Путь к ресурсу (`/`). В данном случае слеш является указанием на корневой каталог. Если бы мы хотели сделать
  запрос на `www.example.com/someResource` - вместо `/` было бы указано `/someResource`*;
- Версия протокола (`HTTP/1.1`).

> Для обозначения ссылок сервер, на ресурс в рамках сервера и т.д. существует несколько терминов, некоторые из
> которых вам могут быть знакомы. Рассмотрим на примере `http://www.example.com/someResource`:
> - `www.example.com` - хост или доменное имя ресурса. По упрощенном понимании - адрес сервера, к которому мы
    > обращаемся. Хоть это и не совсем корректно, и не всегда верно;
> - `/someResource` - путь к ресурсу на сервере;
> - `http://www.example.com/someResource` - **URL** (Uniform Resource Locator). Состоит из протокола (здесь - `http`),
    > доменного имени и пути к ресурсу. Именно в таком виде обычно указывается адрес ресурса в браузере.

#### Параметры запроса

Кроме того, в пути к ресурсу может передаваться не только его адрес на сервере, но и параметры, передающую какую-то
полезную нагрузку.

На этом моменте важно понимать, что ресурс - это не обязательно нечто статическое вроде
HTML-документа или файла. При обращении к ресурсу сервер может выполнять некий программный код, результат которого
будет возвращен как ответ на запрос. Например, если мы работаем с калькулятором, который выполняет вычисления на
сервере, путь к ресурсу может выглядеть как `calculator.com/sum`, а параметрами будут передаваться числа, которые
требуется сложить. Ответ в таком случае может содержать результаты вычисления. При этом адрес ресурса будет одним и
тем же, но фактический ответ будет зависеть от значений переданных параметров.

Передача параметров выглядит примерно так: `calculator.com/sum?param1=10&param2=11`. Здесь `calculator.com/sum` -
адрес ресурса, `?` - символ-разделитель между адресом и параметрами, `param1` и `param2` - имена (ключи) параметров, а
10 и 11 - соответствующие им значения. Имена параметров регламентированы для каждого конкретного адреса, обычно их можно
узнать в документации для конкретного приложения.

Теоретически значения параметров могут содержать любые символы, с поправкой на правила кодирования URL. Этот
механизм определяет правила передачи тех или иных символов, что можно наблюдать, например, при передаче в
запросе кириллицы, пробелов и некоторых других символов. На данном этапе не будем углубляться в эту тему - на данном
этапе это больше запутает, чем поможет. Остановимся на том, что при большом желании можно передать почти что угодно.

Также параметры запроса позволяют передавать несколько значений по одному ключу - что-то вроде массива. Форма записи
схожа с передачей нескольких параметров: `calculator.com/sum?el=1&el=2&el=3`. В данном случае для параметра `el`
передаются одновременно значения 1, 2 и 3.

В HTTP-запросе параметры передаются вместе с адресом ресурса в стартовой строке:

```http request
GET /sum?el=1&el=2&el=3 HTTP/1.1
Host: calculator.com
...
```

> **!NB**: Формально HTTP никак не ограничивает максимальную длину URL. Но различные браузеры и серверы могут иметь
> ограничения на длину URL или предельно допустимый размер запроса в байтах - у каждого свои. Исторически сложилось
> так, что длину URL стараются ограничить ~2000 символов. Обычно это избыточно и URL намного короче, но это накладывает
> ограничение на объемы информации, которые можно передать параметрами запроса.

#### Заголовки

Далее в нашем примере идут **заголовки запроса** (request headers). В них содержится ряд информации о запросе,
предоставляемой в следующем виде: `Header-Name: value`.

Так, в нашем запросе фигурирует обязательный заголовок `Host` с адресом сервера, к которому мы обращаемся, а также
ряд опциональных заголовков: `User-Agent`, `Accept`, `Accept-Language`, `Accept-Encoding`, `Connection`.

В данном случае заголовки сообщают информацию о клиенте (здесь - браузер и его версию), поддерживаемых типах ответа,
предпочитаемом языке ответа и т.д.

Заголовков может быть много, в т.ч. можно создавать собственные заголовки, при условии, что и клиент, и сервер будут
знать о них. Как правило, заголовки запроса передают с запросом метаинформацию - как чисто техническую. (пример выше),
так и что-то более специфическое - например, данные, позволяющие идентифицировать пользователя на сервере.

#### Тело запроса

Еще одна опциональная часть HTTP-запроса - тело. Оно отсутствует в примерах запросов выше, но является важной
составляются коммуникации, поскольку позволяет передавать данные более комфортно, чем параметры запроса.

Именно через тело запроса обычно передаются на сервер файлы или другие относительно тяжелые массивы информации. Чаще
всего мы будем сталкиваться с передачей текстовой информации, которая будет оформлена в виде JSON или XML. Это
позволяет более комфортно обрабатывать данные на сервере.

К сожалению, с помощью браузера не получится качественно продемонстрировать передачу тела запроса. Но в ближайших
статьях мы познакомимся с HTTP-клиентами, которые позволяют конфигурировать и передавать запросы, в т.ч.
взаимодействовать с телом запроса. В виде текста тело запроса можно представить как JSON/XML/обычный текст,
условно отделенный от остальной части запроса.

Основная мысль данного пункта: тело запроса - один из основных способов передать на сервер полезную нагрузку.

### HTTP-ответ

HTTP-ответ - то, что вернет сервер в результате обработки запроса. Ответ имеет структуру, во многом схожую с
запросом, ниже приведен условный пример:

```http request
HTTP/1.1 200 OK
Date: Mon, 23 May 2005 22:38:34 GMT
Content-Type: text/html; charset=UTF-8
Content-Length: 155
Last-Modified: Wed, 08 Jan 2003 23:11:55 GMT
Server: Apache/1.3.3.7 (Unix) (Red-Hat/Linux)
ETag: "3f80f-1b6-3e1cb03b"
Accept-Ranges: bytes
Connection: close

<html>
  <head>
    <title>An Example Page</title>
  </head>
  <body>
    <p>Hello World, this is a very simple HTML document.</p>
  </body>
</html>
```

Постараемся разобраться с содержимым.

#### Строка состояния

В данном случае представлена как `HTTP/1.1 200 OK`. Содержит версию протокола (`HTTP/1.1`) и **статус ответа** (`200
OK`).

Со статусами ответа вы, скорее всего знакомы в том или ином виде. Например, с широко известным статусом 404 - "not
found".

Статусов достаточно много, с ними можно ознакомиться, например, здесь:
[ссылка](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%BA%D0%BE%D0%B4%D0%BE%D0%B2_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D1%8F_HTTP).

Отмечу лишь разбиение статусов на группы по первой цифре кода:

- 1xx: информационные коды. Например, готовность сервера принимать дальнейшие запросы, необходимость переключиться
  на иной протокол и пр. В прикладных задачах с этими кодами сталкиваются редко, они более полезны в разрезе
  инфраструктурных задач.
- 2xx: статусы, говорящие об успешном выполнении запроса. Чаще всего - указанный выше код 200, означающий, что
  запрос выполнен успешно.
- 3xx: статусы для перенаправления. В соответствии с ними запрос необходимо отправить по другому адресу, указанному
  в ответе. Зачастую такая переадресация обрабатывается клиентом автоматически. Могут относиться как к временному,
  так и к перманентному переносу. Может быть актуально при переезде сервиса на другой адрес или в более узких задачах;
- 4xx: ошибка на стороне клиента. Сюда относится некорректно сформированный запрос, отказ сервера в обработке из-за
  отсутствия авторизации или прав доступа, неизвестный адрес ресурса (тот самый 404) и пр.;
- 5xx: ошибка сервера. В данном случае клиент отправил корректный запрос, но сервер почему-то не смог его корректно
  обработать - из-за своей внутренней ошибки, недоступности самого сервера, превышения допустимого времени на
  обработку запроса и т.д.

#### Заголовки ответа

Блок схож с заголовками запроса. Содержит метаинформацию об ответе. Список заголовков динамический, также могут быть
добавлены собственные заголовки.

В данном случае содержит информацию о дате и генерации ответа, дате и времени последнего изменения ресурса,
типе содержимого в ответе и его размере в байтах, информацию о сервере и т.д.

Правила оформления заголовков те же, что и в заголовках запроса.

#### Тело ответа

Эта часть ответа содержит основную полезную нагрузку. Может быть представлена в виде текста, оформленного в том или
ином виде, включая JSON, XML, HTML и т.д. Также может представлять собой файл, закодированный тем или иным образом.
В обоих случаях формат тела будет указан в заголовках ответа.

В примере выше тело ответа представлено HTML-документом:

```html

<html>
    <head>
        <title>An Example Page</title>
    </head>
    <body>
        <p>Hello World, this is a very simple HTML document.</p>
    </body>
</html>
```

В дальнейшем мы чаще всего будем передавать в теле ответа JSON.

### В завершение

Сегодня мы лишь начали знакомство с HTTP. Некоторые аспекты мы разберем подробнее в следующих уроках, но многие вещи
останутся за пределами курса, как неважные на начальных этапах.

Также стоит понимать, что HTTP - далеко не единственный способ сетевой коммуникации. А модель "запрос-ответ" - не
единственный возможный способ передачи сообщений между клиентом и сервером. Но с большой долей вероятности эти
подходы будут основными на проектах, с которыми вам придется работать.

## Stateful и Stateless

Всю коммуникацию в Сети можно разделить на две большие группы: **stateful** (с сохранением состояния) и
**stateless** (без сохранения состояния). Эти термины применимы не только к сетевой коммуникации, но сегодня постараемся
разобраться с ними именно в этом контексте*.

> *Это, на самом деле, проблематично, потому что разные сферы применения данных терминов пересекаются в любой системе.
> И даже в разрезе сетевой коммуникации эти понятия могут иметь различные коннотации и оговорки, исходя из
> конкретного вопроса.
>
> Именно в этом пункте постараемся ограничить зону применения характеристиками протоколов сетевой коммуникации.

Stateless-коммуникация означает, что каждое сообщение от клиента будет восприниматься сервером независимо - на момент
получения сообщения сервер не знает, кто прислал это сообщение, присылал ли этот клиент сообщения ранее, что было в
предыдущих сообщениях и т.д. Безусловно, в частном случае сервер может идентифицировать отправителя уже в процессе
обработки такого сообщения. Например, по информации, которая содержится в сообщении - обычно в заголовках запроса, 
если речь о HTTP. Но важно понимать, что возможность и необходимость подобной идентификации зависит от конкретной
системы.

Соответственно коммуникацию по принципу stateful позволяет понимать, кто является отправителем сообщения или иную
информацию еще на этапе его получения.

Исходя из того, какой подход нам нужен в разрабатываемой системе, можно выбирать конкретные протоколы, которые будут
использоваться. Так, рассматриваемый выше HTTP является stateless-протоколом. Это означает, что каждый новый 
HTTP-запрос воспринимается сервером в отрыве от всех предыдущих, независимо от того, были запросы от этого клиента 
ранее, какими были эти запросы и т.д. 

HTTP закрывает большинство типовых задач, но, например, не может инициировать сообщение от сервера к клиенту - 
только реагировать на запросы. Хотя бы потому что ничего не знает о том, какие активные клиенты сейчас 
взаимодействуют с этим сервером. Это может быть неудобно, если мы пишем приложение вроде чата, где серверу 
необходимо оповещать клиент о сообщениях, которые отправляет другой пользователь*. Для таких случаев может 
потребоваться использовать другой протокол коммуникации.

> *Это, на самом деле, не отменяет технической возможности реализовать чат с коммуникацией по HTTP, но не факт, что 
> такой подход будет эффективным. 

На данном этапе сложно описать многие плюсы и минусы stateful и stateless и провести сравнительный анализ - для 
этого придется давать теоретическую базу по многих смежных темам, включая архитектуру приложений. Однако сами 
термины будут неоднократно встречаться в дальнейшем как в курсе, так и в вашей карьере. И их базовое понимание на 
ранних этапах выглядит полезным.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
>
> Канал: https://t.me/ViamSupervadetVadens
>
> Мой тг: https://t.me/ironicMotherfucker
>
> **Дорогу осилит идущий!**
