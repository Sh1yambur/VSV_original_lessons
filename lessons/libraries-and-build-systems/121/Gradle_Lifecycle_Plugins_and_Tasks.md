# Gradle. Жизненный цикл. Плагины и таски

Мы уже знакомы с правилами и инструментами, на базе которых работает сборка проекта в Maven. Сегодня постараемся
разобраться с основами идентичного механизм в Gradle. Какие-то термины будут уже знакомы, какие-то - будут иметь
иное значение, а что-то окажется совсем новым.

Поехали!

## Жизненный цикл

Жизненный цикл сборки в Gradle - набор последовательных операций, фаз, который описывает процесс анализа необходимых
для сборки действий и их выполнение.

В отличие от Maven, жизненный цикл не зависит от того, какие действия должны происходить в процессе сборки - при
идентичной терминологии (lifecycle и phases), в Gradle эти термины применяются к более высокому уровню абстракции и
описывают именно последовательность действий самой системы сборки, а не последовательность действий при сборке проекта.

Так, любая сборка посредством Gradle имеет 3 фазы:

![img.png](gradleLifecycle.png)

#### Фаза инициализации

В рамках первой фазы Gradle "выполняет"* файл `settings.gradle` (или аналогичного kts-файла), на основании
чего определяет какие проекты (модули в терминах Maven) участвуют в сборке. Также во время этой фазы создаются
объекты для настроек и
проектов, участвующих в сборке**.

> *Помните, что файлы конфигурации в Gradle - это, по сути, скрипты. Т.е. написанное в них выполняется как программа,
> написанная на Groovy/Kotlin DSL. Это также означает, что там, при желании, можно даже написать какую-то свою
> логику, не имеющую отношения к сборке, и она будет выполнена. Это пригодится нам чуть позже.

> **При углублении во внутренние детали Gradle удобнее оперировать его собственными объектами, в силу того, что
> синтаксис для их создания и конфигурации может быть разнообразен, со временем устаревает и перестает поддерживаться.
>
> В прошлой статье уже упоминалось, что в Gradle одни и те же вещи можно описать с использованием различного
> синтаксиса, в зависимости от версии Gradle и/или принятых в команде проекта практик.
>
> В рамках курса мы не будем слишком углубляться в то, какиеми объектами оперирует Gradle в своем внутренней
> структуре, но иногда будут содержаться отсылки на некоторые из них, если это позволит упростить описание
> каких-либо механизмов. Выше речь идет об объекте Settings и объектах Project (по одному на каждый модуль). По сути,
> это обычные Java-объекты - сам Gradle написан на Java (а также Groovy и Kotlin - языках, работающих на базе JVM).

Как видите, данная фаза (как и последующие) - не про конкретные шаги сборки проекта, пусть и стандартизированные.
Она про то, что делает система сборки для обеспечения процесса этой самой сборки. И это ключевой момент в
сегодняшней статье - именно он и обеспечивает ту гибкость Gradle, о которой говорилось ранее.

#### Фаза конфигурации

Во время этой фазы Gradle обрабатывает (выполняет) `build.gradle` каждого проекта в сборке и на основании этого строит
граф
тасок (задач, от англ. - task). Наиболее близкая к таске аналогия из Maven - цель плагина. Именно таски в Gradle
выполняют полезную нагрузку при сборке. И в `build.gradle` можно указать зависимость тасок друг от друга. Кроме того,
в рамках плагина таски тоже могут зависеть от других тасок.

![img.png](gradleTaskGraphes.png)

Такой граф позволяет системе сборки понять, в каком порядке таски должны выполняться, а также определить те из них,
которые можно выполнять параллельно, что позволяет оптимизировать и ускорить процесс сборки.

На картинке выше в правой части описан граф, который строится для обычного Java-приложения - именно такой
используется в рассмотренном нами ранее [примере](https://github.com/KFalcon2022/gradle-sample).

#### Фаза выполнения

Как понятно из названия, именно в рамках этой фазы выполняются таски, определенные в фазе конфигурации. Выполнение
происходит в соответствии с построенным графом.

По сути, именно эта фаза и является сборкой проекта в узком смысле слова. Если мы проведем параллели с любым из
жизненных циклов Maven - весь он и будет представлять фазу выполнения в Gradle. Вне зависимости от того, о каком из
Maven-lifecycle мы говорим.

Документация Gradle содержит достаточно показательный пример, демонстрирующий работу различных фаз сборки:
[ссылка](https://docs.gradle.org/current/userguide/build_lifecycle.html#example). Это возможно как раз из-за природы
файлов конфигураций, о чем упоминалось в сноске выше.

## Плагины

Концептуально, плагины в Gradle мало чем отличаются от плагинов в Maven. И те, и другие - некая "библиотека",
которая содержит конкретные задачи(цели). Только в Gradle задача имеет название task, а в Maven - goal.

В такой коннотации единственным значимым отличием будет то, что в рамках Gradle-плагина можно описать зависимость одних
задач от других. В Maven это не так актуально, поскольку определения порядка выполнения конкретных действий лежит на
механизме жизненного цикла.

Прежде чем перейдем к специфике Gradle, еще раз подчеркну, что Gradle и Maven плагины НЕ являются совместимыми.

### Виды плагинов по издателю

Важно понимать, что плагины в Gradle - это и скелет, и мышцы системы сборки одновременно. Без плагинов Gradle не
имеет практически никаких полезных для разработчика функций.

При этом вполне логично, что плагин для Gradle может написать каждый - вполне распространенная практика, когда в
рамках проекта или группы проектов пишутся и поддерживаются собственными плагины, решающие узкие задачи сборки.

Также есть и широко известные плагины от различных компаний и авторов, которые применяются во множестве проектов.
Сюда, например, можно отнести плагины для взаимодействия с Nexus (мы его упоминали в заключительной статье о Maven)
или для интеграции с Docker (скорее всего, вы слышали об этом инструменте, даже если и не знакомы с ним), а также
множество иных, решающих те, или иные популярные проблемы.

И, наконец, "Core"-плагины, которые разрабатывает сам Gradle. Как правило, это плагины, которые предоставляют
стандартные механизмы сборки для проектов, написанных на различных языках программирования, плагины для
упаковки (в JAR и иные архивы) или публикации (в удаленный репозиторий) артефактов и другие плагины, решающие
широкие или узконаправленные, но популярные задачи - вплоть до плагинов для интеграции с IDE и плагинов для проверки
codestyle. С полным списком можно ознакомиться здесь:
[ссылка](https://docs.gradle.org/current/userguide/plugin_reference.html).

Завершая этот пункт, стоит добавить, что одни плагины могут использовать - и, соответственно, подключать (**применять**
в терминах Gradle) в проект, другие плагины. Так, например, плагин `java` подключит также плагин `base`, обеспечивающий
привычный нам жизненный цикл сборки (в узком смысле), задачу `clean` и пр.

### Виды плагинов по способу реализации

Плагины в Gradle можно разделить на два больших блока:

1. **Бинарные** (или компилируемые) плагины. Пишутся на Java или ином языке программирования, поставляются в виде
   JAR для использования системой сборки;
2. **Скриптовые** (или сценарные) плагины. Плагины, написанные на Groovy/Kotlin DSL. Такие плагины можно описать
   прямо в build.gradle (или эквивалентном kts-файле) или вынести в отдельный файл. Не требуют компиляции.

Рассмотрим каждый из них более подробно.

#### Бинарные плагины

Наиболее близкая аналогия к Maven-плагинам из мира Gradle. По сути, представляет собой Java/Kotlin/ДругойЯзык-проект,
организованный в соответствии с требованиями к плагину, содержит классы, реализующие интерфейсы `Plugin`, `Task` и пр.

Иными словами, это именно то, что обычно и понимают под плагином, когда говорят про Maven или Gradle. Поставляются
из репозитория в упакованном (обычно в JAR) виде для использования системой сборки.

Альтернативно, самописный бинарный плагин может лежать в том же репозитории, что и использующий его проект, в
отдельной директории buildSrc. В таком случае, плагин "поставляется" в виде исходного кода, а не JAR. Но это
достаточно редкий сценарий использования.*

> *На самом деле, "бинарный" плагин можно реализовать прямо в `build.gradle`, определив в нем класс-наследник `Plugin`.
> Но мы не будем в это углубляться, чтобы не вводить путаницу в терминологии.
>
> Подробнее можно посмотреть здесь:
> [ссылка](https://docs.gradle.org/current/userguide/custom_plugins.html#sec:writing_a_simple_plugin).

Именно в виде бинарных плагинов поставляется вся ключевая функциональность в Gradle. В том числе уже знакомые нам
плагины `java` и `application`.

Рассмотрим синтаксис подключения плагинов, рекомендованный на данный момент:

```groovy 
plugins {
   id 'java'
   id 'io.github.gradle-nexus.publish-plugin' version '1.3.0'  
}
```

Важно понимать, что для Core-плагинов нельзя указать версию плагина - они поставляются вместе с Gradle и именно от
версии Gradle зависит версия таких плагинов. В остальных случаях указание версии обязательно.

Существуют и иные способы подключения плагинов, но рассматривать их сейчас не имеет особого смысла - кроме того, что
они устаревшие, они также могут иметь концептуальные отличия в подключении и, соответственно, определенные
ограничения, в которые не хочется углубляться на данном этапе.

#### Скриптовые плагины

Скриптовые плагины предназначены для решения узких задач, актуальных для данного конкретного проекта. Они
описываются с помощью Groovy/Kotlin DSL и не требуют отдельной компиляции. По сути, это просто еще один файл с
инструкциями для сборки (вроде `build.gradle`), который можно подключить и использовать в самом `build.gradle`.

На практике скриптовый плагин часто сводится к написанию одной или нескольких тасок (и сценарий их использования),
каждую из них можно воспринимать как функцию (метод), который может быть применен наравне с тасками из бинарных
плагинов.

В общем-то, эти таски можно расположить прямо в `build.gradle`, если они используются только в нем. Но при
необходимости использовать такие таски в нескольких модулях проекта их можно вынести в отдельный gradle-файл
(или kts-файл), который будет подключаться в `build.gradle`. Тем самым и придя к той концепции, которая и
подразумевается под скриптовым плагином:)

Высшая точка развития такого плагина - он может быть переписан в виде бинарного плагина, чтобы использоваться в
различных проектах. Но обычно с помощью скриптовых плагинов решаются настолько специфические задачи, что в дальнейшей
эволюции нет особого смысла.

Рассмотрим пример написания простейшего скриптового "плагина", состоящего из одной таски `printProjectName`, которая
должна будет выполниться до таски `clean`.

Создадим в директории с `build.gradle` файл `customScript.gradle` со следующим содержимым:

```groovy
tasks.register('customTask') {
    doLast {
        println project.name
    }
}

clean.dependsOn('customTask')
```

В рамках курса мы не будем слишком углубляться в Groovy DSL, поэтому тело таска останется без объяснений. 
`tasks.register` - один из способов добавить таск, сделав его доступным для использования.


Далее добавим в `build.gradle` после plugins-блока следующую строку:

```groovy
apply from: './customScript.gradle'
```

Эта строка позволяет включить в сценарий сборки (`build.gradle`) сценарий, описанный в другом файле. Т.е., по сути, 
применить скриптовый плагин.

Теперь, если запустить в проекте `gradle clean`, сначала будет выполнен `customTask`, который выведет в консоль имя
проекта*, а лишь затем выполнит таску `clean`.

> *В нашем случае - значение `rootProject.name` из `settings.gradle`. Если бы в проекте было несколько модулей -
> значение зависело бы от модуля, в котором мы применили наш самописный плагин.

На практике самописные плагины - относительно редкое явление. Особенно для определения каких-то специфических для
сборки тасок - их зачастую располагают прямо в `build.gradle`.

Тем не менее стоит понимать, что всегда можно создать gradle-файл с определенными инструкциями и подключить его в
`build.gradle`, после чего эти инструкции будут выполняться так же, как если бы были определены в самом файле сборки.
Это может сильно облегчить жизнь, если в новом для вас проекте сборка будет вести себя не так, как вы ожидаете, при
этом `build.gradle` будет содержать ссылки на другие файлы - как минимум, теперь вы знаете, куда стоит копать в
таких ситуациях:)

## Задачи

Задачи, они же таски - единица полезной нагрузки, поставляемая в рамках плагина или определенная в проекте - как
часть скриптового плагина или прямо в `build.gradle`.

На самом деле, эта тема достаточно глубокая, особенно если касаться написания собственных тасок - придется
разбираться в синтаксисе предоставляемого Gradle DSL, объектах самого Gradle и других тонкостях, чтобы действительно
хорошо разобраться что к чему. Впрочем, это же актуально и для плагинов.

Но поскольку текущая задача состоит в знакомстве с Gradle, а не его изучении на углубленном уровне, предлагаю
сконцентрироваться на нескольких аспектах, понимание которых либо важно на ранних этапах, либо просто позволит
чувствовать себя более комфортно при работе с этой системой сборки.

### Виды задач

Все таски в Gradle можно разделить на две группы:

1. **Задачи действий** (_Actionable tasks_). Это задачи, которые выполняют полезную нагрузку - компилируют, упаковывают
   и выполняют
   другую
   работу, необходимую при сборке проекта;
2. **Задачи жизненного цикла** (_Lifecycle tasks_). Это задачи, которые сами по себе ничего не делают, но позволяют
   уложить порядок
   выполнения других задач в общепринятый порядок.

> **!NB**: Не путайте жизненный цикл сборки в Gradle и задачи жизненного цикла. Это совершенно разные вещи. 

Вторая группа - по сути, аналог жизненного цикла из Maven. Т.е. это набор задач, которые поставляются в рамках
плагина и уже связаны между собой в определенный порядок. В свою очередь, им вменяется зависимость от других задач -
задач действий, которая определяется в рамках используемого плагина и/или в файле сборки - `build.gradle`. Таким
образом, задача жизненного цикла может зависеть от множества задач действий.

Нужно понимать, что обе эти категории - логические, они не обусловлены какими-то синтаксическими ограничениями.
Ничто не мешает привязывать задачи действий к другим задачам действий, это тоже распространенная практика.
Назначение lifecycle-задач - обеспечение стандартного процесса сборки, что позволяет иметь общепринятые команды для
сборки проекта (вроде `gradle build`) и стандартный же порядок задач в различных проектах, тем самым упрощая жизнь
разработчикам, особенно при переходе с одного проекта на другой.

При этом в отличие от Maven, в Gradle ничто не мешает сделать полностью свой процесс сборки, введя свои задачи
жизненного цикла (или ограничившись actionable-задачами), который и будет использоваться в рамках команды.

Классическим примером задач жизненного цикла являются задачи из плагина `base`: `check`, `assemble`, `build`.
Подробнее о назначении каждой можно почитать
[здесь](https://docs.gradle.org/current/userguide/base_plugin.html#sec:base_tasks).

### Зависимость задач

Для обеспечения порядка выполнения задач в Gradle существует несколько директив, определяющих как реальную
зависимость между задачами (например, потому что таск `A` может использовать результат таска `B`), так и относительный
порядок выполнения.

Итак, Gradle предоставляет четыре основных свойства, определяющих зависимость задач друг от друга:

1. `dependsOn`. Мы уже использовали его выше. Указывает, что задача может быть выполнения только после выполнения
   другой задачи. Т.е. даже если команда сборки для Gradle не содержит связанной задачи - связанная задача будет
   выполнена. Это наиболее распространенный инструмент для указания зависимостей между тасками в пользовательских
   сценариях.

```groovy
clean.dependsOn('customTask')
```

2. `mustRunAfter`. _Задача2_ должна выполняться после _Задачи1_, но если _Задача1_ не используется в текущей сборке -
   это никак не ограничивает выполнение _Задачи2_. Т.е. Для `gradle Задача2 Задача1` первой выполнится _Задача1_,
   несмотря на явный порядок в самой команде. Но для `gradle Задача2` выполнится лишь _Задача2_. При связи через
   `dependsOn` в обоих случаях выполнились бы обе задачи.

```groovy
clean.mustRunAfter('customTask')
```

3. `shouldRunAfter`. Менее строгий вариант `mustRunAfter`. Оба варианта работают идентично. Но `shouldRunAfter`
   позволяет игнорировать порядок выполнения, если он приведет к цикличному запуску задач или при параллельном
   выполнении тасок.

```groovy
clean.shouldRunAfter('customTask')
```

4. `finalizedBy`. Отношение, позволяющее указать таску, которая обязательно выполнится после указанной, даже если та
   завершится неудачно. Это отношение по принципу работы напоминает `finally` в Java. В примере ниже `customTask`
   всегда будет выполняться после `clean`, независимо от успешности выполнения самого `clean`.

```groovy
clean.finalizedBy('customTask')
```

### Вспомогательные задачи

Также момент, который может сильно облегчить жизнь - таски из группы `help`. Они не нужны для сборки проекта, но
позволяют получить информацию по нему. Например, какие модули включены в проект, список доступных тасок, дерево
зависимостей (с учетом транзитивных зависимостей) и прочее.

Конечно, в этом не так много смысла, если работать через IDEA - эти возможности уже внедрены в GUI и обычно удобнее
использовать именно его, а не получать эту информацию в консоли. Но в ряде случаев это все еще может пригодиться -
например, при поиске по дереву зависимостей*, при использовании нестандартных или не имеющих интеграции с GUI
вспомогательных тасок.

> *На мой взгляд, эта функция реализована в IDEA крайне неудобно и использовать консоль в этом случае быстрее и
> комфортнее.

Но даже если вы используете GUI - знакомство с вспомогательными тасками хотя бы даст вам представление о информации,
которую из Gradle точно можно достать без использования костылей.

### Информационные атрибуты задач

Если открыть вкладку Gradle в IDEA - можно увидеть, что таски сгруппированы по определенному принципу. В зависимости
от подключенных плагинов список групп может частично отличаться, но скорее всего вы увидите `build`, `build setup`,
`help` и другие.

После работы с Maven это может вогнать в ступор - ведь там с аналогичным оформлением были расположены файлы
жизненного цикла и плагины (с содержащимися в них целями). Но в Gradle аналогичного жизненного цикла нет, а
группировка происходит явно не по плагинам - они вообще в этом окне никак не отражены.

В общем-то, ларчик открывается просто: таск в Gradle содержит атрибут `group`, на основании которого таски и
группируются. К слову, эта же группировка используется и при вызове `gradle tasks` в консоли. Если же группа не
указана - таска будет отнесена к группе `other`.

Кроме того, существует и информационный атрибут `description`, в который можно поместить описание таски. Его
содержимое в IDEA можно увидеть, если навести на конкретную таску в окне взаимодействия с Gradle.

Добавим эти атрибуты нашей таске, которую написали выше:

```groovy
tasks.register('customTask') {
    group 'ownGroup'
    description 'Print the project name in console'
    doLast {
        println project.name
    }
}
```

### Заключение

Конечно, за один раз охватить настолько обширные темы как плагины и таски невозможно. Это требует знания и 
синтаксиса, и объектов Gradle и многих иных нюансов. Поэтому первое, что я рекомендую сделать - уложить в голове 
именно ключевые интерфейсы, которыми оперирует Gradle в рамках своей жизнедеятельности. На данном этапе рекомендую 
выделить Project, Plugin и Task. Уже опираясь на них и, хотя бы верхнеуровнево, понимая их зоны ответственности и 
отношения между собой, можно уложить в голове то, как работает Gradle в целом. И уже на этот базис накладывать 
конкретный синтаксис, который вы можете увидеть в `build.gradle`. Иначе многообразие синтаксических конструкций, 
бесконечно расширяемого - как самим Gradle, так и плагинами - DSL и просто обилие информации в любых более-менее 
серьезных источниках приведет к каше, а как следствие - к магическому мышлению. 

Хорошая новость в том, что никто не требует от начинающих специалистов хорошего знания систем сборки - скорее всего, 
при работе с коммерческим проектом в первое время вас никто не подпустит к скриптам сборки, а если и допустят - то 
только к мелким правкам зависимостей. Но отсюда и плохая новость - отсутствие потребности писать скрипты сборок 
приводит к слабым знаниям у разработчика, а следственно - стрессу и ошибкам тогда, когда эти знания пригодятся.

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
> 
> Канал: https://t.me/ViamSupervadetVadens
> 
> Мой тг: https://t.me/ironicMotherfucker
> 
> **Дорогу осилит идущий!**
