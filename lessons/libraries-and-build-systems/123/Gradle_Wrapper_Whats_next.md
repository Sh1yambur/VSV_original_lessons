# Gradle. Знакомство с Gradle Wrapper. Что дальше?

Данная статья будет заключительной для подраздела "Gradle" и для раздела "Системы сборки" в целом. В ней мы ближе
познакомимся с Gradle Wrapper, который неоднократно упоминался в предыдущих статьях и рассмотрим направления для
дальнейшего изучения Gradle.

## Gradle Wrapper

В силу того, что различные проекты могут быть написаны с использованием различных, в том числе не совместимых, версий
Gradle и при этом такие проекты вполне могут оказаться одновременно на компьютере конкретного разработчика - логично
использовать инструмент, который позволит работать с этими системами сборки без установки и конфигурации каждой
конкретной версии вручную. Тем более, установка Gradle предполагает в т.ч. определение переменных окружения
(`GRADLE_HOME`, `PATH`), что еще больше затрудняет установку и взаимодействие с несколькими версиями Gradle в рамках
одной машины.

Именно таким инструментом и является Gradle Wrapper. Он позволяет как работать с Gradle конкретной версии через
консоль, не устанавливая эту версию в полном смысле слова, так и автоматизирует процесс "установки" и обновления
(установки новой версии) конкретной версии Gradle для конкретного проекта.

### Состав Gradle Wrapper

При знакомстве со структурой Gradle-проекта, мы уже разбирали, из чего состоит Gradle Wrapper. Тезисно повторим эти
моменты:

1. `gradle-wrapper.properties`. Файл с настройками для Gradle Wrapper, лежит в директории
   `${projectHome}/gradle/wrapper`. Нас, как правило, интересует `distributionUrl` - путь для скачивания конкретной
   версии Gradle. Именно в пути этого файла можно увидеть (и поправить, если надо) версию Gradle, которую будет
   использовать Gradle Wrapper в данном проекте. Остальные настройки представляют меньший интерес на данном этапе.
   Подробнее здесь: [документация](https://docs.gradle.org/current/userguide/gradle_wrapper.html#sec:adding_wrapper);
2. `gradle-wrapper.jar`. Находится в той же директории, что и `gradle-wrapper.properties`. Скрипты для установки
   конкретной версии Gradle на основании файла настроек;
3. `gradlew` и `gradlew.bat`. Находятся в корневой директории проекта. Скрипты для работы с Wrapper'ом. Для
   UNIX-подобных (MacOS, Linux и т.д.) систем и Windows соответственно.

### Создание Wrapper'а

Строго говоря, Wrapper не является обязательной частью Gradle-проекта, хоть обычно и создается по умолчанию, в т.ч.
при создании проекта через IDEA. Де-факто, создание Gradle Wrapper - результат работы Gradle-таски `wrapper`. Таким
образом, создание Wrapper'а для работы с различными версиями Gradle требует установки на компьютер Gradle хоть
какой-нибудь версии. Зачастую, это берет на себя IDE, тем самым лишая этот процесс наглядности. Но всегда можно
попробовать сделать это вручную.

В данной статье этот пункт больше направлен на то, чтобы объяснить, что создание Wrapper'а - условно-ручная,
конфигурируемая опция. Т.е. при вызове `gradle wrapper` в консоли можно указать набор параметров для Wrapper'а. В
документации по ссылке выше есть перечень параметров, которые можно указать.

### Использование

С точки зрения использования Gradle Wrapper на практике, синтаксис практически идентичен использованию Gradle через
консольный интерфейс. И во многом подобен работе с Maven через `mvn`. Таким образом, информацию из данного пункта можно
использовать как для работы с Wrapper'ом, так и для работы с установленным Gradle. Разница будет только в
используемой команде.

Обращение к установленному Gradle (вне зависимости от ОС):

```shell
> gradle 
```

Обращение к Gradle Wrapper в UNIX-подобных системах (запуск Shell-скрипта):

```shell
> ./gradlew 
```

Обращение к Gradle Wrapper в Windows (запуск bat):

```shell
> gradle.bat 
```

После этого, подобно использованию `mvn`, мы можем указать цепочку тасок, которые должны быть выполнены.
Единственное, что стоит помнить - таски в Gradle могут быть выполнены в порядке, отличном от указанного в консоли,
если между этими тасками есть отношения `mustRunAfter` или `shouldRunAfter`.

Простейший пример вызова таски `build` для Gradle-проекта с помощью Gradle Wrapper:

```shell
> ./gradlew build
```

Также перед названием задачи может использоваться префикс ":":

```shell
> ./gradlew :build
```

":" - указатель на проект (или подпроект), для которого выполняется таска. Например, если наш проект `gradle-sample`
имеет дочерний проект (в терминах Maven - модуль) - `gradle-subproject`, то мы можем выполнить сборку только
проекта `gradle-subproject` с помощью следующей команды:

```shell
> ./gradlew gradle-subproject:build
```

Или аналогичной с ":":

```shell
> ./gradlew :gradle-subproject:build
```

Использование ":" в начале можно воспринимать как "корневой проект:". Т.е. обращение `:gradle-subproject:build`
звучит как "_Выполни задачу `build` для проекта по пути 'корневой проект:gradle-subproject_". И отсюда следует
достаточно важное различие в сборке с указанием ":" и без.

Если мы в подобном проекте, содержащем подпроект, вызовем

```shell
> ./gradlew build
```

То будет выполнена сборка как для основного проекта (`gradle-sample`), так и для подпроекта `gradle-subproject`.

Но если мы вызовем

```shell
> ./gradlew :build
```

То задача будет выполнена сборка только для `gradle-sample`. А `gradle-subproject` будет проигнорирован. Потому что
`:build` можно трактовать как "выполни команду `корневой проект:build`"*.

> *Стоит понимать, что идея расшифровки ":" в начале задачи как "корневой проект:" - лишь удобный способ запомнить
> отличие обращения к таске с использованием ":" и без него на начальном этапе работы. Сам Gradle не вкладывает такого
> смысла. Но в момент, когда вы столкнетесь с некорректностью этой аналогии - полагаю, она уже не будет вам нужна:)

Как говорилось выше, можно вызывать цепочку задач:

```shell
> ./gradlew clean build
```

И, наконец, использовать различные параметры для задач - как специфичные для задачи, так и общие, определяемые
Gradle (использование кэша, приндутельный запуск, исключение задачи и другие):

```shell
> ./gradlew sthTask --sth-option-with-value=sthValue
```

```shell
> ./gradlew sthTask --sth-option-without-value
```

На мой взгляд, это достаточный базис синтаксиса для работы с Gradle (или Gradle Wrapper) через консольный интерфейс,
достаточный для первых лет разработки. И позволяющий более осознанно и гибко использовать IDEA для работы с Gradle -
ведь это, по сути, лишь обертка над консольным интерфейсом.

Со временем, особенно при плотной работе с Gradle, придется углубиться и выйти за пределы данной статьи. Но, полагаю,
к этому моменту вам будет вполне комфортно изучать документацию самого Gradle, а не статьи для новичков:)

### Maven Wrapper

В данном пункте мы не будем в полном смысле слова знакомиться с Maven Wrapper, лишь отметим несколько ключевых
моментов:

1. Концепция Maven Wrapper полностью аналогична концепции Gradle Wrapper;
2. Maven куда более стабилен от версии к версии, чем Gradle, что делает Wrapper для него менее актуальным. Но даже
   он со временем обрастает изменениями и новшествами, что и стало причиной появления Wrapper'а;
3. Как и в случае с Gradle, синтаксис работы с консольным интерфейсом через `mvn` и `mvnw`/`mvnw.cmd` (скрипты для
   работы с Maven Wrapper) отличается лишь обращением к самой команде, в остальном оставаясь идентичным;
4. Документацию и базовые инструкции по работе с Maven Wrapper можно найти по ссылке:
   [Maven Wrapper](https://maven.apache.org/wrapper/).

## Что дальше?

На самом деле, при похожей структуре статей по Maven и Gradle, на данный момент можно сказать, что с Maven мы 
познакомились в большем объеме. Во многом это связано с многообразием возможностей и синтаксиса, предоставляемого 
Gradle - из-за этого тяжело давать информацию, которая будет объяснять принципы работы различных механизмов в Gradle 
на концептуальном уровне, при этом давать синтаксис и какую-то полезную в практических задачах информацию. Чтобы 
разобрать это действительно качественно, пришлось бы каждую тему разбивать на три статьи: "Принципы работы", 
"синтаксис" и "практика использования". В этом плане Maven сильно проще за счет однообразия синтаксиса - все три 
пункта можно объяснять на одних и тех же примерах.

Из описанного выше и следуют рекомендации по дальнейшему изучению:

1. **Объекты Gradle**. Стоит разобраться с зонами ответственности Project, Settings, Configuration и прочими - хотя 
   бы на интерфейсном уровне. Именно в этом лежит ключ к пониманию, как работает и какими понятиями оперирует Gradle;
2. **Groovy и/или Kotlin DSL**. Как и любой DSL, языки конфигурации в Gradle весьма гибкие в контексте своих задач и 
   относительно легко расширяемы - в т.ч. посредством DSL-плагинов. Стоит осознать, что файлы конфигурации - по сути,
   просто скрипты, практически программный код, который можно писать в относительно свободной форме. Именно 
   знание (или хотя бы хорошее понимание) синтаксиса лежит в основе комфортной работы с Gradle. Без этого иногда 
   становится проблемой даже поддержка планов сборки даже существующего проекта, не требующего частых правок;
3. **Знакомство с ключевыми плагинами**. Сюда можно отнести как Core-плагины - вроде `java` и `java-library`, так и 
   наиболее популярные в современной Java-разработке сторонние плагины - например, плагины для работы со Spring Boot.
   Но, полагаю, до получения коммерческого опыта лучше ограничиться Core-плагинами, остальными лишь использовать по 
   мере необходимости - иначе есть шанс начать изучать не то что нужно, или не с теми акцентами, которые необходимы 
   в прикладных задачах;
4. **Написание собственных тасок и/или плагинов**. Если опыт написания плагинов нужен не слишком часто, то собственные 
   задачи на Groovy/Kotlin DSL стоит попытаться писать - хотя бы для знакомства с синтаксисом и возможности понять, 
   что за самопальные таски вы видите в проекте на своем первом месте работы:)
5. **Работа с зависимостям**и. Мы познакомились с базовым синтаксисом, но огромное количество инструментов осталось за 
   пределами курса. И именно эти инструменты, вероятно, еще не раз послужат поводом для удивления, когда система 
   сборки будет вести себя не так, как вы ожидали;
6. **Работа с многопроектными сборками**. Как и в Maven, этот пункт не слишком сложен на практике, но требует время для 
   того, чтобы с ним разобраться. И это может стать хорошей точкой входа для знакомства с плагином `java-library`.

К сожалению, изучение систем сборки за пределами реальных проектов - трудоемкое и не слишком эффективное занятие. 
Плохая новость заключается в том, что в рамках коммерческой разработки редко приходиться работать с системами сборки 
в рамках конкретных задач, что приводит к достаточно слабому уровню владения системами сборки у разработчиков и, как 
следствие, ступору и ошибкам, когда таки приходится коснуться конфигурации Gradle за пределами базовых операций по 
работе с зависимостями. 

Но, как и всегда, дорогу осилит идущий. И понимая потенциальные узкие места в профессиональном развитии, 
прорабатывать их гораздо проще:)

#### На сегодня все!

![img.png](../../../commonmedia/justTheoryFooter.png)

> Если что-то непонятно или не получается – welcome в комменты к посту или в лс:)
> 
> Канал: https://t.me/ViamSupervadetVadens
> 
> Мой тг: https://t.me/ironicMotherfucker
> 
> **Дорогу осилит идущий!**
